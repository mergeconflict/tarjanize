{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "SymbolGraph",
  "description": "Root structure representing the entire symbol graph of a workspace.\n\nThe symbol graph captures all symbols and their dependencies within a Rust workspace. Crates are represented as their root modules, which contain symbols and nested submodules.",
  "type": "object",
  "required": [
    "crates",
    "edges",
    "workspace_name"
  ],
  "properties": {
    "crates": {
      "description": "All crates in the workspace. Each crate is represented as its root module, which contains all symbols and submodules.",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Module"
      }
    },
    "edges": {
      "description": "Dependency edges between symbols. An edge from A to B means A depends on B (A uses B in its definition).",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Edge"
      },
      "uniqueItems": true
    },
    "workspace_name": {
      "description": "Name of the workspace, derived from Cargo.toml or the root directory.",
      "type": "string"
    }
  },
  "definitions": {
    "Edge": {
      "description": "A dependency edge between two symbols.\n\nAn edge from A to B means that A depends on B - that is, A's definition references B in some way (type annotation, function call, trait bound, etc.).\n\n# Normalization\n\nDependencies are normalized for consistency: - Enum variants collapse to their parent enum - Associated items collapse to their container (impl or trait) - Module references are skipped (modules aren't compilation units)",
      "type": "object",
      "required": [
        "from",
        "to"
      ],
      "properties": {
        "from": {
          "description": "Fully qualified path of the dependent symbol (the one that has the dependency).",
          "type": "string"
        },
        "to": {
          "description": "Fully qualified path of the dependency (the symbol being depended on).",
          "type": "string"
        }
      }
    },
    "Module": {
      "description": "A module (or crate root) containing symbols and submodules.\n\nModules form a tree structure where each module can contain: - Symbols (functions, structs, enums, traits, impl blocks, etc.) - Child submodules\n\nThe crate's root module (lib.rs or main.rs) is the top of this tree.",
      "type": "object",
      "required": [
        "name",
        "symbols"
      ],
      "properties": {
        "name": {
          "description": "Module name. For the crate root, this is the crate name.",
          "type": "string"
        },
        "submodules": {
          "description": "Child modules. Omitted if the module has no submodules.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Module"
          }
        },
        "symbols": {
          "description": "Symbols defined directly in this module. A symbol is either a module-level definition (function, struct, etc.) or an impl block.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Symbol"
          }
        }
      }
    },
    "Symbol": {
      "description": "A symbol in the crate - either a module-level definition or an impl block.\n\nSymbols are the vertices in the dependency graph. Each symbol has a name, source file, compilation cost estimate, and kind-specific details.",
      "type": "object",
      "oneOf": [
        {
          "description": "A module-level definition, analogous to `ra_ap_hir::ModuleDef`.\n\nThis includes functions, structs, enums, unions, traits, consts, statics, type aliases, and macros.",
          "type": "object",
          "required": [
            "module_def"
          ],
          "properties": {
            "module_def": {
              "type": "object",
              "required": [
                "kind"
              ],
              "properties": {
                "kind": {
                  "description": "The kind of definition: \"function\", \"struct\", \"enum\", \"union\", \"trait\", \"const\", \"static\", \"type_alias\", \"macro\", \"module\".",
                  "type": "string"
                },
                "visibility": {
                  "description": "Visibility specifier. Examples: \"pub\", \"pub(crate)\", \"pub(restricted)\". Absent for private items.",
                  "type": [
                    "string",
                    "null"
                  ]
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "description": "An impl block, analogous to `ra_ap_hir::Impl`.\n\nImpl blocks are anonymous (you can't name them with a path), but they're important compilation units. At least one of `self_type` or `trait` must be present to satisfy Rust's orphan rules.",
          "type": "object",
          "required": [
            "impl"
          ],
          "properties": {
            "impl": {
              "type": "object",
              "properties": {
                "self_type": {
                  "description": "Fully qualified path to the self type (the type being implemented). Absent if the self type is in another crate, or for blanket impls.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "trait": {
                  "description": "Fully qualified path to the trait being implemented. Absent for inherent impls or if the trait is in another crate.",
                  "type": [
                    "string",
                    "null"
                  ]
                }
              }
            }
          },
          "additionalProperties": false
        }
      ],
      "required": [
        "cost",
        "file",
        "name"
      ],
      "properties": {
        "cost": {
          "description": "Approximate cost (unitless) of compiling this symbol.\n\nThis is used for load balancing when partitioning the graph. Given two symbols A and B: - Serial compilation cost: A.cost + B.cost - Parallel compilation cost: max(A.cost, B.cost)\n\nCurrently estimated from syntax node size in bytes.",
          "type": "number",
          "format": "double",
          "minimum": 0.0
        },
        "file": {
          "description": "Path to the symbol's file relative to the crate root.",
          "type": "string"
        },
        "name": {
          "description": "Symbol name. For impl blocks, this is formatted as the impl appears in source, e.g., \"impl Trait for Type\".",
          "type": "string"
        }
      }
    }
  }
}