# Known Problems

## Diesel `table!` Macro-Generated Modules

### Problem

Diesel's `table!` macro generates modules containing struct definitions that tarjanize cannot extract. For example:

```rust
table! {
    project_image (id) {
        id -> Uuid,
        // ...
    }
}
```

This expands to something like:

```rust
mod project_image {
    pub struct table;
    // columns, helper types, etc.
}
```

The impls generated by diesel (e.g., `impl TableNotEqual<...> for project_image::table`) ARE extracted, and their anchors correctly point to paths like `nexus_db_schema::schema::project_image::table`. However, the `project_image` module and `table` struct are not extracted as symbols.

This causes the condense phase to filter out these anchors (since they reference non-existent symbols), leaving diesel impls with empty anchor sets.

### What We've Tried

1. **`module.children(db)` and `module.declarations(db)`**: These HIR methods don't return the macro-generated modules.

2. **Walking the module's AST via `definition_source()`**: The source AST contains `table!` macro invocations, not the expanded modules.

3. **Resolving impl self type paths via `sema.resolve_path()`**: Returns `None` for diesel-generated paths like `disk::table`.

4. **Checking `impl_.self_ty(db).is_unknown()`**: Returns `true` for diesel impls, confirming rust-analyzer can't resolve the types.

5. **Looking for macro-generated modules via impl self type ADTs**: When `self_ty.is_unknown()` is true, we can't get the ADT or its containing module.

### Root Cause

Rust-analyzer expands the `table!` macro (evidenced by the impls being visible), but the resulting modules/types aren't fully integrated into the semantic model. Specifically:

- The impls exist and can be iterated via `module.impl_defs(db)`
- But their self types resolve to "unknown"
- Path resolution for the generated types fails
- The generated modules don't appear in `children()` or `declarations()`

This appears to be a limitation in how rust-analyzer handles declarative macro expansions that generate module structures.

### Potential Solutions

1. **Parse the `table!` macro invocations directly**: Extract table names from the macro syntax and create symbols for them. Downside: fragile, diesel-specific, won't capture actual dependencies.

2. **Accept missing anchors**: Filter invalid anchors in condense and proceed without them. Downside: diesel impls won't have proper orphan rule constraints.

3. **Create synthetic symbols**: When an anchor references a non-existent path, create a placeholder symbol. Downside: synthetic symbols won't have correct dependencies.

4. **Upstream fix in rust-analyzer**: Report the issue and hope for better macro expansion support. Downside: external dependency, unknown timeline.

### Current Status

Anchors are correctly generated via AST extraction but point to symbols that don't exist in the graph. The condense phase filters these out, resulting in diesel impls with empty anchor sets.

## Minimal Reproducer

Several test fixtures were created in `tests/fixtures/` to isolate the issue:

### 1. `macro_module_gen/` - Local macro (WORKS)

```rust
macro_rules! table {
    ($name:ident) => {
        pub mod $name { pub struct table; }
    };
}
table!(users);
```

**Result**: `module.children(db)` returns the `users` module. Anchors resolve correctly.

### 2. `macro_module_gen_ext/` - Workspace member macro (WORKS)

The macro is defined in a separate crate (`table_macro/`) that's a workspace member:

```toml
[workspace]
members = ["table_macro"]
[dependencies]
table_macro = { path = "table_macro" }
```

**Result**: `module.children(db)` returns the macro-generated modules. Anchors resolve correctly.

### 3. `diesel_expanded/` - Pre-expanded diesel code (WORKS)

The exact code that diesel's `table!` macro generates, but written as plain Rust without macro invocation.

**Result**: All modules and symbols are extracted correctly.

### 4. Actual diesel dependency (FAILS)

```toml
[dependencies]
diesel = { version = "2", features = ["postgres"] }
```

```rust
use diesel::table;
table! { users (id) { id -> Int4, name -> Text, } }
```

**Result**: `module.children(db)` returns 0. `module.declarations(db)` returns 0. No symbols extracted.

## Root Cause (Confirmed)

**rust-analyzer does NOT integrate macro expansions from external crates.io dependencies into its HIR.**

The distinction is:
- **Workspace member crates**: Macro expansions are fully integrated into HIR. `children()` and `declarations()` return the generated modules.
- **External crates.io dependencies**: Macro expansions are NOT integrated. `children()` and `declarations()` return empty results.

This explains why:
- Our simplified macros (defined locally or in workspace members) work perfectly
- Diesel's `table!` macro (from crates.io) produces zero symbols

The `cargo expand` output shows diesel's macro DOES expand correctly at the rustc level. The issue is specifically with rust-analyzer's semantic analysis not incorporating expansions from external crate macros.

## Work Done Attempting to Fix This

### What Worked ✓

1. **Manual path building via `path_to_root(db)`** (Session 1): Instead of relying on `canonical_path()`, we walk the module hierarchy to build fully-qualified paths. This works for macro-generated items where `canonical_path()` returns `None`.

2. **AST-based anchor extraction** (Session 1): When `impl_.self_ty(db).is_unknown()`, we extract the self type path from AST and build the anchor path using the module prefix. This correctly generates paths like `nexus_db_schema::schema::project_image::table`.

3. **AST-based trait type parameter extraction** (Session 1): For impls like `impl From<LocalType> for ExternalType`, when rust-analyzer can't resolve the trait, we extract type parameters from the trait path in the AST.

4. **Reference type unwrapping** (Session 1): Added `RefType` unwrapping so `impl From<&LocalType>` correctly extracts `LocalType` as an anchor.

5. **`crate::` prefix handling** (Session 1): Convert `crate::module::Type` to `crate_name::module::Type` in AST extraction.

6. **Condense-phase anchor filtering** (Session 2): Filter out anchors that don't exist in the symbol index instead of panicking. This handles external types that AST extraction can't distinguish from local types.

7. **Regression tests** (Session 1): Added `test_external_trait_with_local_type_param`, `test_external_trait_with_ref_type_param`, `test_crate_prefixed_self_type`.

### What Partially Worked ~

1. **Walking module AST for inline modules** (Session 2): Works for source-level inline modules (like `mod tests {}`), but NOT for macro-generated modules. The `definition_source()` method returns the macro invocation syntax, not the expanded code.

### What Didn't Work ✗

1. **`module.children(db)`** (Session 2): Doesn't return diesel's macro-generated modules.

2. **`module.declarations(db)`** (Session 2): Also doesn't return macro-generated modules.

3. **`sema.resolve_path()` for diesel types** (Session 2): Returns `None` for all diesel-generated paths like `disk::table`, `project_image::table`, etc.

4. **Extracting modules via impl self type ADTs** (Session 2): When `self_ty.is_unknown()` (true for all diesel impls), we can't get the ADT or its containing module.

5. **Filtering external types during extraction** (Session 2): Tried requiring multi-segment paths (too restrictive—rejects valid single-segment local types) and checking if first segment is a local module (too hacky and unreliable).

6. **`sema.expand_macro_call()`** (Session 3): We implemented macro expansion using Semantics' `expand_macro_call()` method. Key findings:
   - The method requires AST nodes from a tree cached by Semantics (via `sema.parse_or_expand(file_id)`)
   - For **workspace member macros**: Returns full expansion content (e.g., `expanded_len=55` for our test macro)
   - For **external crate macros (diesel)**: Returns `Some(...)` but with **empty content** (`expanded_len=0`)
   - Processing all crates (not just workspace members) doesn't help - the issue is in the expansion itself
   - This confirms rust-analyzer can "expand" external macros but the result is empty/unusable

### Current State

The extraction phase correctly generates anchor paths via AST fallback (e.g., `nexus_db_schema::schema::project_image::table`). However, the symbols these anchors point to don't exist in the graph because rust-analyzer doesn't expose the macro-generated modules through any API we've found. The condense phase filters these invalid anchors, resulting in diesel impls with empty anchor sets.

## Promising Direction: rustc's `-Z unpretty` Flags

Since rust-analyzer can't expand external crate macros, we investigated using rustc directly. The compiler has several output formats that provide the information we need.

### Available Formats (requires nightly)

```bash
cargo +nightly rustc -- -Z unpretty=<format>
```

| Format | Description |
|--------|-------------|
| `expanded` | Macro-expanded source (what `cargo expand` uses) |
| `hir` | High-level IR as pseudo-Rust code |
| `hir,typed` | HIR with type annotations inline |
| `hir-tree` | HIR as a debug tree structure |
| `thir-tree` | Typed HIR tree (includes resolved types) |
| `thir-flat` | Flattened THIR |
| `mir` | Mid-level IR |

### Key Finding: `hir,typed` Has Resolved Method Calls

The `hir,typed` format embeds resolved method/function references in curly braces:

```rust
// Inherent method call
((::core::fmt::Formatter::write_str as
    for<'a, 'b> fn(&'a mut Formatter<'_>, &'b str) -> Result<(), Error>
    {Formatter::<'_>::write_str})((f as &mut Formatter<'_>), ("table" as &str)))

// Trait method call
{<table as Table>::all_columns}

// Associated function
{query_builder::nodes::StaticQueryFragmentInstance::<table>::new}

// Trait method on generic type
{<Result<(), diesel::result::Error> as Try>::branch}
```

The format is:
- `{Type::method}` for inherent methods
- `{<Type as Trait>::method}` for trait methods

### Example Output

```bash
cd /tmp/diesel_expand && cargo +nightly rustc -- -Z unpretty=hir,typed 2>&1 | grep -o '{[^}]*::[^}]*}'
```

Returns resolved references like:
```
{Formatter::<'_>::write_str}
{<table as Table>::all_columns}
{query_builder::nodes::StaticQueryFragmentInstance::<table>::new}
{<Result<(), diesel::result::Error> as Try>::branch}
{diesel::expression::ops::numeric::Add::<columns::id, ...>::new}
```

### THIR Has Even More Detail

The `thir-tree` format shows fully resolved `DefId`s:

```
Call {
    ty: FnDef(DefId(2:12569 ~ core[0591]::fmt::{impl#12}::write_str), ['{erased}])
    ...
}
```

This shows:
- The exact `DefId` of the function
- Which impl block (`{impl#12}`)
- The crate (`core[0591]`)

### Proposed Approach

1. **Preprocess with rustc**: For each crate, run `cargo +nightly rustc -- -Z unpretty=hir,typed`

2. **Parse the output**: Extract both:
   - Module structure and symbols (like `cargo expand`)
   - Resolved method calls from `{...}` annotations

3. **Build dependency graph**: Use the resolved references to build accurate dependencies, including method calls that rust-analyzer couldn't resolve.

### Trade-offs

**Pros:**
- Gets fully expanded macros from external crates
- Has resolved method calls (critical for accurate dependencies)
- Uses the same expansion rustc uses for compilation

**Cons:**
- Requires nightly Rust
- Output format is unstable/undocumented
- Need to mirror workspace structure for multi-crate workspaces
- Adds preprocessing step

### Open Questions

1. **File structure preservation**: `cargo expand` (and rustc's unpretty) outputs the entire crate as one blob. Need to either:
   - Accept single-file output per crate
   - Parse and split back into original file structure
   - Use `cargo expand path::to::module` for per-module expansion

2. **Workspace handling**: Need to expand each crate separately while preserving inter-crate references

3. **Stability**: The `{...}` annotation format in `hir,typed` is undocumented. Need to assess how stable it is across rustc versions.

## Better Direction: Using rustc as a Library

Rather than parsing rustc's text output formats, we can use rustc directly as a library to access the HIR/THIR data structures programmatically. This is what tools like Clippy and Miri do.

### Setup Required

**rust-toolchain.toml** (pin to specific nightly):
```toml
[toolchain]
channel = "nightly-2024-10-20"
components = ["rustc-dev", "rust-src", "llvm-tools"]
```

**Cargo.toml**:
```toml
[package.metadata.rust-analyzer]
rustc_private = true
```

**Code structure**:
```rust
#![feature(rustc_private)]

extern crate rustc_driver;
extern crate rustc_hir;
extern crate rustc_interface;
extern crate rustc_middle;

use rustc_driver::Callbacks;
use rustc_middle::ty::TyCtxt;

struct MyAnalyzer;

impl Callbacks for MyAnalyzer {
    fn after_analysis(
        &mut self,
        _compiler: &interface::Compiler,
        tcx: TyCtxt<'_>,
    ) -> Compilation {
        // Access HIR/THIR here via tcx
        for id in tcx.hir_free_items() {
            let item = tcx.hir_item(id);
            // Walk items, extract types, build dependency graph
        }
        Compilation::Stop
    }
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    rustc_driver::RunCompiler::new(&args, &mut MyAnalyzer).run()
}
```

### Available APIs

| API | Purpose |
|-----|---------|
| `tcx.hir_free_items()` | Iterate all top-level HIR items |
| `tcx.hir_item(id)` | Get a specific HIR item |
| `tcx.type_of(def_id)` | Get resolved type for a definition |
| `tcx.thir_body(def_id)` | Get THIR for a function body (has resolved method calls) |
| `tcx.def_path_str(def_id)` | Get string path for a DefId |

### THIR Contains Resolved Method Calls

The THIR (Typed HIR) has exactly what we need - fully resolved function/method calls:

```rust
// In THIR, a method call looks like:
ExprKind::Call {
    ty: FnDef(DefId(crate::module::Type::method), substs),
    fun: ...,
    args: ...,
}
```

The `DefId` tells us exactly which function/method is being called, including:
- Which impl block it comes from
- The full path (`crate::module::Type::method`)
- Generic substitutions

### Integration with Cargo

To analyze a full workspace, we need to invoke our custom driver via cargo:

```rust
// cargo-tarjanize-driver.rs
fn main() {
    let cargo = std::env::var("CARGO").unwrap_or("cargo".into());
    std::process::Command::new(cargo)
        .arg("check")  // or "build"
        .env("RUSTC_WRAPPER", std::env::current_exe().unwrap())
        .status()
        .unwrap();
}
```

This makes cargo invoke our driver instead of rustc for each crate.

### Trade-offs vs rust-analyzer

| Aspect | rust-analyzer | rustc as library |
|--------|---------------|------------------|
| Macro expansion | ❌ Empty for external crates | ✅ Full expansion |
| Method resolution | ✅ Works (when types known) | ✅ Works |
| Stability | Stable crates.io releases | ❌ Unstable, pin to nightly |
| Incremental | ✅ IDE-optimized | Partial |
| Setup complexity | Low | High (nightly, rustc-dev) |

### Implemented Solution

We created `cargo-tarjanize`, a custom rustc driver that:

1. Uses `RUSTC_WRAPPER` to intercept compiler invocations
2. Implements `Callbacks::after_analysis` to walk HIR/THIR
3. Extracts symbols and dependencies with full macro expansion
4. Outputs the symbol graph in JSON format

The old rust-analyzer based `tarjanize-extract` crate has been removed since
the rustc driver approach provides complete macro expansion and accurate
dependency resolution.

### References

- [rustc-dev-guide: rustc_driver](https://rustc-dev-guide.rust-lang.org/rustc-driver/intro.html)
- [rustc-dev-guide: HIR](https://rustc-dev-guide.rust-lang.org/hir.html)
- [Example driver code](https://github.com/rust-lang/rustc-dev-guide/blob/main/examples/rustc-driver-example.rs)
- [Building your own rustc_driver](https://jyn.dev/rustc-driver/)
